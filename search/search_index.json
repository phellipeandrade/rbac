{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RBAC","text":"<p>Hierarchical Role-Based Access Control (RBAC) for Node.js and TypeScript. The library is curried for flexible setup, keeps dependencies to a minimum, and ships with first-class TypeScript types.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Operation-first design: Define operations as strings, globs, or regular expressions, and check them with a simple <code>can</code> helper.</li> <li>Hierarchical roles: Reuse permissions with inheritance and update definitions at runtime without rebuilding your app.</li> <li>Runtime conditions: Attach synchronous, async, promise-based, or callback-based guards to any permission.</li> <li>Adapters and middleware: Load or persist role definitions through MongoDB, MySQL, or PostgreSQL adapters and guard routes with Express, NestJS, or Fastify helpers.</li> <li>Multi-tenant ready: Scope role definitions to tenants using the optional adapter utilities.</li> </ul>"},{"location":"#quick-tour","title":"Quick tour","text":"<pre><code>import RBAC from '@rbac/rbac';\n\nconst rbac = RBAC({ enableLogger: false })({\n  user: { can: ['products:find'] },\n  admin: { can: ['products:*'], inherits: ['user'] }\n});\n\nawait rbac.can('user', 'products:find'); // true\nawait rbac.can('admin', 'products:delete'); // true via inheritance and wildcard\n</code></pre> <p>Use the navigation to explore setup instructions, conceptual guides, feature comparisons, and practical usage recipes.</p>"},{"location":"basic-usage/","title":"Basic Usage","text":"<p>This section shows how to configure RBAC, model permissions, and integrate the library into common application layers.</p>"},{"location":"basic-usage/#configure-rbac","title":"Configure RBAC","text":"<p>Create an instance by passing configuration and a role map. Configuration accepts a custom logger and a <code>enableLogger</code> flag to turn logging on or off.</p> <pre><code>import RBAC from '@rbac/rbac';\n\nconst rbac = RBAC({ enableLogger: true })({\n  guest: { can: ['products:find'] }\n});\n</code></pre>"},{"location":"basic-usage/#define-roles-and-permissions","title":"Define roles and permissions","text":"<p>A role definition accepts:</p> <ul> <li><code>can</code>: An array of strings or objects with a <code>name</code> and optional <code>when</code> guard. Strings match directly, and patterns can use glob wildcards or regular expressions.</li> <li><code>inherits</code>: An optional array of roles to pull permissions from.</li> </ul> <pre><code>const rbac = RBAC()({\n  user: { can: ['products:find'] },\n  supervisor: {\n    can: [\n      { name: 'products:edit', when: () =&gt; true },\n      { name: 'products:*' } // wildcard\n    ],\n    inherits: ['user']\n  }\n});\n</code></pre> <p><code>when</code> guards can be synchronous, async, a returned Promise, or a callback. They receive the <code>params</code> object passed to <code>can</code>.</p> <pre><code>const rbac = RBAC()({\n  auditor: {\n    can: [\n      { name: 'products:audit:callback', when: (_params, done) =&gt; done(null, true) },\n      { name: 'products:audit:async', when: async () =&gt; true },\n      { name: 'products:audit:promise', when: Promise.resolve(true) }\n    ]\n  }\n});\n</code></pre>"},{"location":"basic-usage/#check-permissions","title":"Check permissions","text":"<p>The <code>can</code> helper resolves inheritance, matches exact operations, globs, or regexes, and evaluates conditional guards when present:</p> <pre><code>await rbac.can('supervisor', 'products:find');\nawait rbac.can('supervisor', 'products:create');\nawait rbac.can('auditor', /products:audit/);\nawait rbac.can('auditor', 'products:audit:async', { requestId: '42' });\n</code></pre>"},{"location":"basic-usage/#update-roles-at-runtime","title":"Update roles at runtime","text":"<p>Add or merge role definitions without rebuilding your application:</p> <pre><code>rbac.addRole('editor', { can: ['products:update'], inherits: ['user'] });\nrbac.updateRoles({\n  user: { can: ['products:find', 'products:share'] }\n});\n</code></pre>"},{"location":"basic-usage/#persist-and-load-roles-with-adapters","title":"Persist and load roles with adapters","text":"<p>Use the optional adapters to store roles in your database. Each adapter supports a customizable table/collection schema and an optional <code>tenantId</code> for multi-tenancy.</p> <pre><code>import { MongoRoleAdapter, MySQLRoleAdapter, PostgresRoleAdapter } from '@rbac/rbac/adapters';\n\nconst mongoAdapter = new MongoRoleAdapter({\n  uri: 'mongodb://localhost:27017',\n  dbName: 'mydb',\n  collection: 'roles'\n});\n\nconst mysqlAdapter = new MySQLRoleAdapter({\n  uri: 'mysql://user:pass@localhost:3306/app',\n  table: 'roles'\n});\n\nconst pgAdapter = new PostgresRoleAdapter({\n  connectionString: 'postgres://user:pass@localhost:5432/app',\n  table: 'roles'\n});\n</code></pre> <p>Adapters expose <code>getRoles</code>, <code>addRole</code>, and <code>updateRoles</code> to manage definitions in storage.</p>"},{"location":"basic-usage/#multi-tenant-rbac","title":"Multi-tenant RBAC","text":"<p>Scope RBAC to a specific tenant by loading role definitions with a <code>tenantId</code>:</p> <pre><code>import { createTenantRBAC, MongoRoleAdapter } from '@rbac/rbac';\n\nconst adapter = new MongoRoleAdapter({\n  uri: 'mongodb://localhost:27017',\n  dbName: 'mydb',\n  collection: 'roles'\n});\n\nconst rbacTenantA = await createTenantRBAC(adapter, 'tenant-a');\nawait rbacTenantA.can('user', 'products:find');\n</code></pre>"},{"location":"basic-usage/#web-framework-middleware","title":"Web framework middleware","text":"<p>Guard routes using the built-in middleware factories for Express, NestJS, and Fastify. Each factory accepts optional callbacks to extract the role and params or to override the default denied response.</p> <pre><code>import RBAC, { createExpressMiddleware } from '@rbac/rbac';\n\nconst rbac = RBAC({ enableLogger: false })({\n  user: { can: ['products:find'] }\n});\n\nconst canFindProducts = createExpressMiddleware(rbac)('products:find');\napp.get('/products', canFindProducts, handler);\n</code></pre> <p>Swap <code>createExpressMiddleware</code> for <code>createNestMiddleware</code> or <code>createFastifyMiddleware</code> to integrate with other frameworks.</p>"},{"location":"comparison/","title":"Comparison","text":"<p>RBAC focuses on performance and flexibility while keeping the API small. This page highlights how it differs from other access-control approaches and how to measure those differences with the built-in benchmarks.</p>"},{"location":"comparison/#where-this-library-stands-out","title":"Where this library stands out","text":"<ul> <li>Operation-oriented permissions: Operations are plain strings that can also be matched with globs or regular expressions, enabling granular checks without designing a resource matrix.</li> <li>Hierarchical roles: Roles can inherit from one another to avoid duplicating permission lists.</li> <li>Conditional guards: Permissions can be gated by callbacks, async functions, or promises so that runtime context influences the decision.</li> <li>Runtime mutability: <code>addRole</code> and <code>updateRoles</code> let you change the role map without restarting your app.</li> <li>Adapter support: Optional MongoDB, MySQL, and PostgreSQL adapters make it straightforward to persist and share definitions across services.</li> <li>Multi-tenant aware: A <code>tenantId</code> can be provided to adapters and the <code>createTenantRBAC</code> helper to isolate role definitions by tenant.</li> </ul>"},{"location":"comparison/#benchmarks","title":"Benchmarks","text":"<p>The repository includes a benchmark suite that compares RBAC against popular alternatives such as <code>accesscontrol</code>, <code>rbac</code>, <code>easy-rbac</code>, and <code>fast-rbac</code> across direct checks, inherited roles, and conditional permissions.</p> <p>Run the suite with:</p> <pre><code>yarn bench\n</code></pre> <p>The script builds large permission sets, executes identical operations against each library, and prints timing results to the console.</p>"},{"location":"comparison/#choosing-the-right-model","title":"Choosing the right model","text":"<ul> <li>Pick this library when you need fast checks on string-based operations, optional glob/regex matching, and minimal setup.</li> <li>Use conditional guards when permissions depend on runtime data such as ownership or tenant membership.</li> <li>Pair the adapters with the multi-tenant helper if your platform isolates permissions per customer or workspace.</li> </ul>"},{"location":"get-started/","title":"Get Started","text":"<p>Follow this guide to install the library, define your first role map, and perform permission checks.</p>"},{"location":"get-started/#1-install-the-package","title":"1) Install the package","text":"<pre><code>npm install @rbac/rbac\n# or\nyarn add @rbac/rbac\n</code></pre> <p>The package ships with TypeScript types and works in JavaScript and TypeScript projects.</p>"},{"location":"get-started/#2-create-a-role-map","title":"2) Create a role map","text":"<p><code>RBAC</code> is a curried factory. First pass configuration, then the role definitions:</p> <pre><code>import RBAC from '@rbac/rbac';\n\nconst rbac = RBAC({ enableLogger: false })({\n  reader: { can: ['articles:find'] },\n  editor: { can: ['articles:update'], inherits: ['reader'] },\n  admin: { can: ['articles:*'] }\n});\n</code></pre> <ul> <li><code>can</code> is an array of operation strings or objects with a <code>when</code> guard.</li> <li><code>inherits</code> lets a role reuse permissions from other roles.</li> </ul>"},{"location":"get-started/#3-check-permissions","title":"3) Check permissions","text":"<p>Use the <code>can</code> function returned by the factory to verify operations. Operations accept strings, glob-style wildcards, or regular expressions:</p> <pre><code>await rbac.can('reader', 'articles:find'); // true\nawait rbac.can('editor', 'articles:find'); // true via inheritance\nawait rbac.can('editor', 'articles:delete'); // false\nawait rbac.can('admin', /articles:/); // true through regex\n</code></pre>"},{"location":"get-started/#4-add-conditions","title":"4) Add conditions","text":"<p>Attach synchronous, asynchronous, Promise-based, or callback guards to permissions to enforce contextual rules:</p> <pre><code>interface Params {\n  ownerId: string;\n  currentUserId: string;\n}\n\nconst rbac = RBAC()({\n  author: {\n    can: [{\n      name: 'articles:update',\n      when: ({ ownerId, currentUserId }) =&gt; ownerId === currentUserId\n    }]\n  }\n});\n\nawait rbac.can('author', 'articles:update', {\n  ownerId: '123',\n  currentUserId: '123'\n}); // true\n</code></pre>"},{"location":"get-started/#5-keep-iterating","title":"5) Keep iterating","text":"<p>Roles can evolve at runtime without rebuilding your application:</p> <pre><code>rbac.addRole('support', { can: ['tickets:find'] });\nrbac.updateRoles({\n  reader: { can: ['articles:find', 'articles:share'] }\n});\n</code></pre> <p>Head to Basic Usage for more end-to-end examples that include adapters and web framework middleware.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#library","title":"Library","text":"<p>Install the package from npm using your preferred package manager:</p> <pre><code>npm install @rbac/rbac\n# or\nyarn add @rbac/rbac\n</code></pre> <p>The published bundle ships with its TypeScript declaration files so IDEs and build pipelines pick up types automatically.</p>"},{"location":"installation/#optional-database-drivers","title":"Optional database drivers","text":"<p>Role adapters are lazy-loaded and expect their respective drivers to be available in your project. Add the dependency for the adapter you plan to use:</p> <ul> <li>MongoDB adapter \u2192 <code>npm install mongodb</code></li> <li>MySQL adapter \u2192 <code>npm install mysql2</code></li> <li>PostgreSQL adapter \u2192 <code>npm install pg</code></li> </ul> <p>Each adapter accepts custom column names and a tenant identifier; see Basic Usage for concrete examples.</p>"},{"location":"installation/#documentation-site","title":"Documentation site","text":"<p>This repository includes a ready-to-use Material for MkDocs configuration. To preview the docs locally:</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre> <p>The site will be available at <code>http://127.0.0.1:8000/</code> by default. To publish to GitHub Pages, run:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>The command builds the static site and pushes it to the <code>gh-pages</code> branch, which GitHub Pages can serve directly.</p>"},{"location":"le-introduction/","title":"Library Essentials (LE) Introduction","text":"<p>This library centers on an operation-first approach to authorization. Instead of tying permissions to resources, you describe the exact operations your application exposes and map roles to those operations.</p>"},{"location":"le-introduction/#how-rbac-is-structured","title":"How RBAC is structured","text":"<ul> <li>Curried factory: <code>RBAC(config)(roles)</code> returns an object with the <code>can</code>, <code>addRole</code>, and <code>updateRoles</code> helpers. Configuration accepts a custom logger and a switch to enable or disable logging.</li> <li>Operations: Any string can be an operation. Use exact matches, glob-style patterns (e.g., <code>products:*</code>), or regular expressions to express permissions at the granularity you need.</li> <li>Roles: Each role lists operations under <code>can</code> and can optionally <code>inherit</code> other roles, creating a hierarchy without repeating permissions.</li> <li>Conditions: Every permission can define a <code>when</code> guard as a boolean, promise, async function, or callback. The guard receives the <code>params</code> object you pass to <code>can</code> and returns a truthy or falsy value.</li> <li>Caching: Permission checks are cached per role to speed up repeated lookups, including glob and regex evaluations.</li> </ul>"},{"location":"le-introduction/#what-happens-during-a-can-check","title":"What happens during a <code>can</code> check","text":"<ol> <li>Resolve the role and expand inherited permissions.</li> <li>Try direct matches (<code>operation</code> string) first.</li> <li>Evaluate glob or regex matches, caching results per role and pattern.</li> <li>If the permission has a <code>when</code> guard, normalize it to an async function and evaluate it with the provided params.</li> <li>Log the outcome when logging is enabled.</li> </ol> <p>Understanding these steps makes it easier to choose between exact operations, patterns, or conditional checks for your own system.</p>"},{"location":"migrating-v1-to-v2/","title":"Migrating from v1 to v2","text":"<p>This guide summarizes the main changes introduced in version 2 of RBAC and how to update your applications.</p>"},{"location":"migrating-v1-to-v2/#main-changes","title":"Main changes","text":"<ul> <li>Complete rewrite in TypeScript. The API remains compatible but the source files are now in TypeScript for better type support and public declarations.</li> <li>Dynamic role updates. The <code>updateRoles</code> function allows modifying permissions at runtime.</li> <li>Database adapters. New adapters for MongoDB, MySQL and PostgreSQL make it possible to automatically load and persist roles.</li> <li>Official middlewares. Middlewares for Express, NestJS and Fastify make protecting routes easier.</li> <li>Multi-tenant support. Use <code>createTenantRBAC</code> to instantiate isolated RBAC instances per tenant.</li> </ul>"},{"location":"migrating-v1-to-v2/#steps-to-update","title":"Steps to update","text":"<ol> <li>Update your <code>package.json</code> dependency to <code>@rbac/rbac@^2.0.0</code> or the latest version.</li> <li>If you use plain JavaScript, no changes are required. For TypeScript, import the types exposed by <code>@rbac/rbac</code>.</li> <li>If you previously loaded roles manually, consider using a database adapter to centralize persistence.</li> <li>Review your calls to <code>RBAC.can</code> and other utilities; the API is the same but <code>when</code> can now be an async function or promise.</li> <li>For a gradual migration, keep your existing <code>.js</code> files and adopt <code>.ts</code> as needed.</li> </ol> <p>For more details check the CHANGELOG.</p>"}]}